<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="eternal0918, ZXP">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          RabbitMQ 学习 - Eternal
        
    </title>

    <link rel="canonical" href="https://dusign.net/2021/08/11/RabbitMQ-学习/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('rabbit.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#RabbitMQ" title="RabbitMQ">RabbitMQ</a>
                            
                        </div>
                        <h1>RabbitMQ 学习</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Eternal on
                            2021-08-11
                        </span>

                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Eternal</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/photography/">Photography</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列"></a>1.消息队列</h1><h2 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p><strong>MQ(message queue)</strong>，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>
<h3 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h3><h4 id="1-流量削峰"><a href="#1-流量削峰" class="headerlink" title="1.流量削峰"></a>1.流量削峰</h4><p>在访问量剧增的情况下，但是应用仍然需要发挥作用，但是这样的突发流量并不常见。而使用消息中间件采用队列的形式可以减少突发访问压力，不会因为突发的超时负荷要求而崩溃</p>
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p>
<h4 id="2-应用解耦"><a href="#2-应用解耦" class="headerlink" title="2.应用解耦"></a>2.应用解耦</h4><p>在项目启动之初是很难预测未来会遇到什么困难的，消息中间件在处理过程中插入了一个隐含的，基于数据的接口层，两边都实现这个接口，这样就允许独立的修改或者扩展两边的处理过程，只要两边遵守相同的接口约束即可。</p>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804172916969.png" alt="image-20210804172916969"></p>
<h4 id="3-异步处理"><a href="#3-异步处理" class="headerlink" title="3.异步处理"></a>3.异步处理</h4><p>通过把把消息发送给消息中间件，消息中间件并不立即处。</p>
<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804173241311.png" alt="image-20210804173241311"></p>
<h3 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h3><h4 id="1-ActiveMQ"><a href="#1-ActiveMQ" class="headerlink" title="1.ActiveMQ"></a>1.ActiveMQ</h4><p><strong>优点：</strong>单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据</p>
<p><strong>缺点:</strong>官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</p>
<h4 id="2-Kafka"><a href="#2-Kafka" class="headerlink" title="2.Kafka"></a>2.Kafka</h4><p>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为<strong>大数据</strong>而生的消息中间件， 以其<strong>百万级 TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</p>
<p><strong>优点:</strong> 性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</p>
<p><strong>缺点：</strong>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用<strong>短轮询方式</strong>，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，<strong>社区更新较慢</strong>；</p>
<h4 id="3-RocketMQ"><a href="#3-RocketMQ" class="headerlink" title="3.RocketMQ"></a>3.RocketMQ</h4><p>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。</p>
<p><strong>优点：</strong> <strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到 0 丢失</strong>,MQ 功能较为完善，还是<strong>分 布式</strong>的，扩展性好,<strong>支持 10 亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ</p>
<p><strong>缺点：</strong> <strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码</p>
<h4 id="4-RabbitMQ"><a href="#4-RabbitMQ" class="headerlink" title="4.RabbitMQ"></a>4.RabbitMQ</h4><p>2007 年发布，是一个在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一。</p>
<p><strong>优点:</strong>由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易 用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,<strong>社区活跃度高</strong>；更新频率相当高 <a href="https://www.rabbitmq.com/news.html" target="_blank" rel="noopener">https://www.rabbitmq.com/news.html</a></p>
<p><strong>缺点：</strong>商业版需要收费,学习成本较高</p>
<h3 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h3><h4 id="1-Kafka"><a href="#1-Kafka" class="headerlink" title="1.Kafka"></a>1.Kafka</h4><p>Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生<strong>大量数据</strong>的互联网服务的数据收集业务。<strong>大型公司</strong>建议可以选用，如果有<strong>日志采集</strong>功能， 肯定是首选 kafka 了。</p>
<h4 id="2-RocketMQ"><a href="#2-RocketMQ" class="headerlink" title="2.RocketMQ"></a>2.RocketMQ</h4><p>天生为<strong>金融互联网</strong>领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</p>
<h4 id="3-RabbitMQ"><a href="#3-RabbitMQ" class="headerlink" title="3.RabbitMQ"></a>3.RabbitMQ</h4><p>结合 erlang 语言本身的并发优势，性能好<strong>时效性微秒级，社区活跃度也比较高</strong>，管理界面用起来十分 方便，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ-的概念"><a href="#RabbitMQ-的概念" class="headerlink" title="RabbitMQ 的概念"></a>RabbitMQ 的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/MQ的核心组件.jpg" alt="MQ的核心组件"></p>
<h3 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h3><p><strong>生产者：</strong>产生数据发送消息的程序是生产者</p>
<p><strong>交换机：</strong>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p>
<p><strong>队列：</strong>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>
<p><strong>消费者：</strong> 消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
<h3 id="RabbitMQ-核心部分"><a href="#RabbitMQ-核心部分" class="headerlink" title="RabbitMQ 核心部分"></a>RabbitMQ 核心部分</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804180816590.png" alt="image-20210804180816590"></p>
<h3 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804180949940.png" alt="image-20210804180949940"></p>
<p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>
<p><strong>Virtual host：</strong>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>
<p><strong>Connection：</strong>publisher／consumer 和 broker 之间的 TCP 连接</p>
<p><strong>Channel：</strong>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP  Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong></p>
<p><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout  (multicast)</p>
<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p>
<p><strong>Binding：</strong>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p>
<h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p>1.官网地址</p>
<p><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a></p>
<p>2.文件上传</p>
<p>上传到/usr/local/software 目录下(如果没有 software 需要自己创建)</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804191104169.png" alt="image-20210804191104169"></p>
<p>3.安装文件(分别按照以下顺序安装) </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/software</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装语言</span></span><br><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">yum install socat -y </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MQ</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接执行</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/software</span><br><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm </span><br><span class="line">yum install socat -y </span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>Docker容器上安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for RabbitMQ 3.9, the latest series</span></span><br><span class="line">docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.9-management</span><br><span class="line"></span><br><span class="line"><span class="comment"># for RabbitMQ 3.8,</span></span><br><span class="line"><span class="comment"># 3.8.x support timeline: https://www.rabbitmq.com/versions.html</span></span><br><span class="line">docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>
<p>4.常用命令(按照以下顺序执行)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加开机启动 RabbitMQ 服务 </span></span><br><span class="line">chkconfig rabbitmq-server on </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动服务 </span></span><br><span class="line">service rabbitmq-server start  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务状态 </span></span><br><span class="line">service rabbitmq-server status</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止服务(选择执行)</span></span><br><span class="line">service rabbitmq-server stop </span><br><span class="line"></span><br><span class="line"><span class="comment">#开启 web 管理插件 (MQ服务开启状态)</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>用默认账号密码(guest)访问地址<code>192.168.158.137:15672</code>出现权限问题（创建一个用户即可）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804201926406.png" alt="image-20210804201926406"></p>
<p>5.添加一个用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建账号</span></span><br><span class="line">rabbitmqctl add_user admin root</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置用户角色</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置用户权限</span></span><br><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class="built_in">read</span>&gt; </span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"><span class="comment">#用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前用户和角色</span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>
<p>6.用新创建的用户进行登录</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804202735267.png" alt="image-20210804202735267"></p>
<p>7.重置命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭应用的命令为</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除的命令为</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动命令为</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
<h3 id="启动服务出现的问题"><a href="#启动服务出现的问题" class="headerlink" title="启动服务出现的问题"></a>启动服务出现的问题</h3><p>问题1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># /sbin/service rabbitmq-server start </span></span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job <span class="keyword">for</span> rabbitmq-server.service failed because the control process exited with error code. See <span class="string">"systemctl st"</span> and <span class="string">"journalctl -xe"</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>解决方案：修改主机名称（只要不是数字就行）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主机名 </span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step1</span></span><br><span class="line">[root@192 ~]<span class="comment"># vim /etc/hostname</span></span><br><span class="line"><span class="comment">#将默认的 localhost.localdomain 更换成自己的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2</span></span><br><span class="line">[root@zxp1 ~]<span class="comment">#  vi /etc/hosts</span></span><br><span class="line"></span><br><span class="line">127.0.0.1   localhost zxp localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost zxp localhost6 localhost6.localdomain6</span><br><span class="line"><span class="comment">#修改一下 localhost.localdomain 即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step3</span></span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=zxp1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>重新开启服务即可</p>
<h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2.Hello World"></a>2.Hello World</h1><p>在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代 表使用者保留的消息缓冲区</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804203048674.png" alt="image-20210804203048674"></p>
<h2 id="Pom依赖"><a href="#Pom依赖" class="headerlink" title="Pom依赖"></a>Pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 生产者 ： 发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//工厂IP连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">"192.168.158.137"</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  生成一个队列</span></span><br><span class="line"><span class="comment">         *  1.队列名称 QUEUE_NAME</span></span><br><span class="line"><span class="comment">         *  2.队列里面的消息是否持久化（存储在磁盘），默认情况消息存储在内存中</span></span><br><span class="line"><span class="comment">         *  3.该队列是否只供一个消费者进行消费，是否进行消息共享true可以多个消费者消费，false只能一个消费者消费</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除，最后一个消费者端开连接以后，该队列一句是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        String message = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  发送一个消费</span></span><br><span class="line"><span class="comment">         *  1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         *  2.路由的Key值是哪个</span></span><br><span class="line"><span class="comment">         *  3.其他参数信息</span></span><br><span class="line"><span class="comment">         *  4.发送消息的信息体</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"发送消息完毕！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804210733893.png" alt="image-20210804210733893"></p>
<h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消费者 接收消息的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.158.137"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明 接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息消费被中断"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  消费者消费消息</span></span><br><span class="line"><span class="comment">         *  1.消费哪个队列</span></span><br><span class="line"><span class="comment">         *  2.消费成功之后是否要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         *  3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         *  4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210804212140403.png" alt="image-20210804212140403"></p>
<h1 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3.Work Queues"></a>3.Work Queues</h1><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805182117612.png" alt="image-20210805182117612"></p>
<h2 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h2><p>一个生产者对应多个消费者，生产者发送多次消息，是采用轮询的机制，公平的分给每一个消费者。</p>
<p>案例中我们会启动两个工作线程，一个消息发送线程</p>
<h3 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个连接的channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> TimeoutException, IOException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"192.168.158.137"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">//创建链接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动两个工作线程"><a href="#启动两个工作线程" class="headerlink" title="启动两个工作线程"></a>启动两个工作线程</h3><p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 工作线程（消费者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息的接收</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受到的消息："</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息接受被取消时，执行下面的操作</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag+<span class="string">"消息者取消消费接口回调逻辑"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  消费者消费消息</span></span><br><span class="line"><span class="comment">         *  1.消费哪个队列</span></span><br><span class="line"><span class="comment">         *  2.消费成功之后是否要自动应答 true 代表自动应答 false 代表手动应答</span></span><br><span class="line"><span class="comment">         *  3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         *  4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        System.out.println(<span class="string">"C2等待接收消息..."</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, cancelCallback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEA设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805190622877.png" alt="image-20210805190622877"></p>
<p>开启连个工作线程</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805200411125.png" alt="image-20210805200411125"></p>
<h3 id="启动一个发送线程"><a href="#启动一个发送线程" class="headerlink" title="启动一个发送线程"></a>启动一个发送线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 生产者 发送大量的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送大量消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  生成一个队列</span></span><br><span class="line"><span class="comment">         *  1.队列名称 QUEUE_NAME</span></span><br><span class="line"><span class="comment">         *  2.队列里面的消息是否持久化（存储在磁盘），默认情况消息存储在内存中</span></span><br><span class="line"><span class="comment">         *  3.该队列是否只供一个消费者进行消费，是否进行消息共享true可以多个消费者消费，false只能一个消费者消费</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除，最后一个消费者端开连接以后，该队列一句是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//从控制台中接收消息</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  发送一个消费</span></span><br><span class="line"><span class="comment">             *  1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">             *  2.路由的Key值是哪个</span></span><br><span class="line"><span class="comment">             *  3.其他参数信息</span></span><br><span class="line"><span class="comment">             *  4.发送消息的信息体</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息完成："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输入<code>AA,BB,CC,DD</code></p>
<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>工作线程1</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805200522823.png" alt="image-20210805200522823"></p>
<p>工作线程2</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805200535438.png" alt="image-20210805200535438"></p>
<h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p>
<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接 收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p>
<h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p><em>不建议使用</em></p>
<p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权 衡,</strong>因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢 失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>， 当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终 使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并 以某种速率能够处理这些消息的情况下使用。</strong></p>
<h3 id="消息应答的方法"><a href="#消息应答的方法" class="headerlink" title="消息应答的方法"></a>消息应答的方法</h3><p><em>常用</em></p>
<p>A.Channel.basicAck(用于肯定确认) </p>
<p>​        RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 </p>
<p>B.Channel.basicNack(用于否定确认) </p>
<p>C.Channel.basicReject(用于否定确认) </p>
<p>​        与 Channel.basicNack 相比少一个参数 </p>
<p>​        不处理该消息了直接拒绝，可以将其丢弃了</p>
<h3 id="Multiple的解释"><a href="#Multiple的解释" class="headerlink" title="Multiple的解释"></a>Multiple的解释</h3><p>手动应答的好处是可以批量应答并且减少网络拥堵 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(deliveryTag,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p><strong>multiple</strong> 的 <strong>true</strong> 和 <strong>false</strong> 代表不同意思</p>
<p><strong>true ：</strong>代表批量应答 channel 上未应答的消息 </p>
<p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5~ 8 的这些还未应答的消息都会被确认收到消息应答</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805202955203.png" alt="image-20210805202955203"></p>
<p><strong>false：</strong>只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805203003390.png" alt="image-20210805203003390"></p>
<p>开发中，一般都设为false</p>
<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805203121883.png" alt="image-20210805203121883"></p>
<h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p>
<p><strong>消费者1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时是不会丢失的，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work03</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TimeoutException, IOException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">"C1等待接收消息，处理时间较短"</span>);</span><br><span class="line">        </span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡 1s</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"接收到的消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  1.消息的标记 tag</span></span><br><span class="line"><span class="comment">             *  2.是否批量应答 false：不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">"消费者取消消费接口回调逻辑"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TimeoutException, IOException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">"C2等待接收消息，处理时间较长"</span>);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="comment">//沉睡 30s</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">"接收到的消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">"消费者取消消费接口回调逻辑"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消息生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消息在手动应答时是不会丢失的，放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> TimeoutException, IOException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//控制台输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产者发出消息："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>睡眠工具类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> *  睡眠工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * second);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException _ignored) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动应答效果演示"><a href="#手动应答效果演示" class="headerlink" title="手动应答效果演示"></a>手动应答效果演示</h3><p>正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805212328867.png" alt="image-20210805212328867"></p>
<p>在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是 由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805212408976.png" alt="image-20210805212408976"></p>
<p>生产者发送信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">aa</span><br><span class="line">生产者发出消息：aa</span><br><span class="line">bb</span><br><span class="line">生产者发出消息：bb</span><br><span class="line">cc</span><br><span class="line">生产者发出消息：cc</span><br><span class="line">dd</span><br><span class="line">生产者发出消息：dd</span><br></pre></td></tr></table></figure>
<p>消费者1接收信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">C1等待接收消息，处理时间较短</span><br><span class="line">接收到的消息：aa</span><br><span class="line">接收到的消息：cc</span><br><span class="line">接收到的消息：dd</span><br><span class="line"><span class="comment"># 2号宕机后，消息由1号接收</span></span><br></pre></td></tr></table></figure>
<p>消费者2接收信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class <span class="string">"org.slf4j.impl.StaticLoggerBinder"</span>.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#StaticLoggerBinder for further details.</span></span><br><span class="line">C2等待接收消息，处理时间较长</span><br><span class="line">接收到的消息：bb（30s后收到）</span><br><span class="line"><span class="comment">#（30s内）停止程序运行（宕机）这时本该传到2号的dd消息，由1号接收</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code -1</span><br></pre></td></tr></table></figure>
<h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong>。</p>
<h3 id="队列如何实现持久化"><a href="#队列如何实现持久化" class="headerlink" title="队列如何实现持久化"></a>队列如何实现持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> durable = <span class="keyword">true</span>;</span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805213716580.png" alt="image-20210805213716580"></p>
<p>Web控制台中持久化与非持久化队列的 UI 显示区</p>
<p>非持久化</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805214151792.png" alt="image-20210805214151792"></p>
<p>持久化（多了个<code>D</code>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805214321459.png" alt="image-20210805214321459"></p>
<p>即使重启 rabbitmq 队列也依然存在</p>
<h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><p>要想让消息实现持久化需要在消息<strong>生产者</strong>修改代码,MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	生产者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非持久化（保存在内存中）</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//持久化（设置生产者发送消息为持久化消息，保存在磁盘上）</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>
<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果<strong>需要更强有力的持久化策略</strong>，则需要<strong>发布确认</strong>的知识。</p>
<h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的话就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
<p>为了避免这种情况，我们可以设置参数 <code>channel.basicQos(1);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">int</span> prefetchCount = <span class="number">1</span>;</span><br><span class="line">	channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>
<p>生产者随机发送消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">生产者发出消息：aa</span><br><span class="line">b</span><br><span class="line">生产者发出消息：b</span><br><span class="line">vv</span><br><span class="line">生产者发出消息：vv</span><br><span class="line">dd</span><br><span class="line">生产者发出消息：dd</span><br></pre></td></tr></table></figure>
<p>消费者1接收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C1等待接收消息，处理时间较短</span><br><span class="line">接收到的消息：aa</span><br><span class="line">接收到的消息：vv</span><br><span class="line">接收到的消息：dd</span><br></pre></td></tr></table></figure>
<p>消费者2接收</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C2等待接收消息，处理时间较长</span><br><span class="line">接收到的消息：b</span><br></pre></td></tr></table></figure>
<p>响应时间短的，处理的量多，响应时间长的，处理的少。（不再是你一个我一个的公平分发）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805220553650.png" alt="image-20210805220553650"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210805220638328.png" alt="image-20210805220638328"></p>
<p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。</p>
<h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。</strong>这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。</strong>一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高 向消费者传递消息的速度。</p>
<p><strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理 的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器) </strong>应该小心使用具有无限预处理 的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807162613453.png" alt="image-20210807162613453"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者1</span></span><br><span class="line"> 		<span class="keyword">int</span> prefetchCount = <span class="number">2</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line"><span class="comment">//消费者2</span></span><br><span class="line"> 		<span class="keyword">int</span> prefetchCount = <span class="number">5</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>
<p>连续发送一堆消息后，随机从某个消费者进行传递，两个消费者随机处理一些自己的消息（数量跟预取值有关），当某个消费者的队列已达到预取值大小，则会传递给其他消费者继续执行（前提：当前消费者的消息队列已达到预取值大小，里面的消息正在等待被处理）</p>
<h1 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4.发布确认"></a>4.发布确认</h1><h2 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h2><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，<strong>所有在该信道上面发布的 消息都将会被指派一个唯一的 ID(从 1 开始)</strong>，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队 列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传 给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信 道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调 方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消 息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<h2 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h2><h3 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布 确认，都需要在 channel 上调用该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure>
<h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><p>这是一种简单的确认方式，它是一种<strong>同步确认发布</strong>的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,<code>waitForConfirmsOrDie(long)</code>这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个确认 方法体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publicMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列的声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量发消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String messgae = i + <span class="string">""</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, queueName, <span class="keyword">null</span>, messgae.getBytes());</span><br><span class="line">        <span class="comment">//单个消息马上进行发布确认</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(messgae+<span class="string">"号消息发送成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"发布"</span> + MESSAGE_COUNT + <span class="string">"个单独确认消息"</span> + <span class="string">"耗时时间："</span> + (end - begin)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807170630862.png" alt="image-20210807170630862"></p>
<h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是同步的，也一样阻塞消息的发布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量发送确认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列的声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量确认消息大小</span></span><br><span class="line">    <span class="keyword">long</span> batchSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量发送消息，批量发布确认</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String message = i + <span class="string">""</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前达到100条消息的时候，批量确认一次</span></span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//发布确认</span></span><br><span class="line">            channel.waitForConfirms();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"发布"</span> + MESSAGE_COUNT + <span class="string">"个批量确认消息"</span> + <span class="string">"耗时时间："</span> + (end - begin) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807192601399.png" alt="image-20210807192601399"></p>
<h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807185934319.png" alt="image-20210807185934319"></p>
<p>消息生产者：只需发消息（每一个消息都含有key-value）就行，无需等待消息发送的全流程是否执行完毕。每一个消息经过处理都会反馈一个消息（成功 / 失败）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步确认发布</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列的声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过lambda表达式创建两个接口（成功的和失败的）</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  1.消息的标记 deliveryTag</span></span><br><span class="line"><span class="comment">     *  2.是否为批量确认 multiple</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//消息确认成功，回调函数</span></span><br><span class="line">    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"确认的消息："</span> + deliveryTag);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//消息确认失败，回调函数</span></span><br><span class="line">    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"未确认的消息："</span> + deliveryTag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一个消息监听器，监听消息哪些成功了，哪些失败了</span></span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量发消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String messgae = i + <span class="string">"消息"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, queueName, <span class="keyword">null</span>, messgae.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"发布"</span> + MESSAGE_COUNT + <span class="string">"个异步发布确认消息"</span> + <span class="string">"耗时时间："</span> + (end - begin) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807192315038.png" alt="image-20210807192315038"></p>
<p>异步发送所造成的结果，消息发送穿插在确认消息的过程中。</p>
<p>可以看到，只处理了确认消息，未确认的消息没有处理</p>
<h3 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h3><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步确认发布</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">    <span class="comment">//队列的声明</span></span><br><span class="line">    String queueName = UUID.randomUUID().toString();</span><br><span class="line">    channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 线程安全有序的一个跳表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">     *功能：</span></span><br><span class="line"><span class="comment">     *  1.将消息的序号和消息进行关联</span></span><br><span class="line"><span class="comment">     *  2.批量删除条目（通过序号）</span></span><br><span class="line"><span class="comment">     *  3.支持高并发（多线程）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过lambda表达式创建两个接口（成功的和失败的）</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  1.消息的标记 deliveryTag</span></span><br><span class="line"><span class="comment">     *  2.是否为批量确认 multiple</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//消息确认成功，回调函数</span></span><br><span class="line">    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量删除</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            <span class="comment">//2.删除已经确认的消息，剩下的就是未确认的消息</span></span><br><span class="line">            ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">            confirmed.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outstandingConfirms.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"确认的消息："</span> + deliveryTag);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//消息确认失败，回调函数</span></span><br><span class="line">    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        String message = outstandingConfirms.get(deliveryTag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印一下未确认的消息</span></span><br><span class="line">        System.out.println(<span class="string">"未确认的消息是:"</span> + message + <span class="string">"未确认的消息tag："</span> + deliveryTag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一个消息监听器，监听消息哪些成功了，哪些失败了</span></span><br><span class="line">    channel.addConfirmListener(ackCallback, nackCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量发消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">        String messgae = i + <span class="string">"消息"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, queueName, <span class="keyword">null</span>, messgae.getBytes());</span><br><span class="line">        <span class="comment">//1.记录所有发送的消息</span></span><br><span class="line">        outstandingConfirms.put(channel.getNextPublishSeqNo(), messgae);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时间</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"发布"</span> + MESSAGE_COUNT + <span class="string">"个异步发布确认消息"</span> + <span class="string">"耗时时间："</span> + (end - begin) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-种发布确认速度对比"><a href="#3-种发布确认速度对比" class="headerlink" title="3 种发布确认速度对比"></a>3 种发布确认速度对比</h3><p><strong>单独发布消息：</strong>同步等待确认，简单，但吞吐量非常有限。 </p>
<p><strong>批量发布消息：</strong> 批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题。 </p>
<p><strong>异步处理：</strong> 最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.单个确认</span></span><br><span class="line">    ConfirmMessage.publicMessageIndividually();     <span class="comment">//耗时800ms左右</span></span><br><span class="line">    <span class="comment">//2.批量确认</span></span><br><span class="line">    ConfirmMessage.publishMessageBatch();           <span class="comment">//耗时130ms左右</span></span><br><span class="line">    <span class="comment">//3.异步确认</span></span><br><span class="line">    ConfirmMessage.publishMessageAsync();            <span class="comment">//耗时55ms左右</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5. 交换机"></a>5. 交换机</h1><p>在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式 称为 ”发布/订阅”.</p>
<p>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘， 另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</p>
<h2 id="Exchanges"><a href="#Exchanges" class="headerlink" title="Exchanges"></a>Exchanges</h2><h3 id="Exchanges-概念"><a href="#Exchanges-概念" class="headerlink" title="Exchanges 概念"></a>Exchanges 概念</h3><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。</p>
<p>相反，<strong>生产者只能将消息发送到交换机(exchange)</strong>，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807201251420.png" alt="image-20210807201251420"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807222327736.png" alt="image-20210807222327736"></p>
<h3 id="Exchanges-的类型"><a href="#Exchanges-的类型" class="headerlink" title="Exchanges 的类型"></a>Exchanges 的类型</h3><p>总共有以下类型： 直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout 发布订阅)</p>
<h3 id="无名-exchange"><a href="#无名-exchange" class="headerlink" title="无名 exchange"></a>无名 exchange</h3><p>之前没有用交换机却仍能够将消息发送到队列，是因为使用的是默认交换，通过空字符串<code>&quot;&quot;</code>进行标识的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">""</span>,<span class="string">"hello"</span>,<span class="keyword">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>
<p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：如果它存在的话,消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的</p>
<h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807222926375.png" alt="image-20210807222926375"></p>
<p>队列的名称我们 来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息。</p>
<p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称 的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次<strong>一旦我们断开了消费者的连 接，队列将被自动删除。</strong></p>
<p>创建临时队列的方式如下: </p>
<p><code>String queueName = channel.queueDeclare().getQueue();</code></p>
<p>创建之后查看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807223219977.png" alt="image-20210807223219977"></p>
<h2 id="绑定（bindings）"><a href="#绑定（bindings）" class="headerlink" title="绑定（bindings）"></a>绑定（bindings）</h2><p>binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807223255696.png" alt="image-20210807223255696"></p>
<h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><h3 id="Fanout-介绍"><a href="#Fanout-介绍" class="headerlink" title="Fanout 介绍"></a>Fanout 介绍</h3><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<strong>广播</strong>到它知道的 所有队列中。系统中默认有些 exchange 类型</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807223632459.png" alt="image-20210807223632459"></p>
<h3 id="Fanout-实战"><a href="#Fanout-实战" class="headerlink" title="Fanout 实战"></a>Fanout 实战</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807225815610.png" alt="image-20210807225815610"></p>
<p>交换机Logs和临时队列的绑定关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807225914504.png" alt="image-20210807225914504"></p>
<p><strong>ReceiveLogs01</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//创建一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个队列(临时队列)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列，队列名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开连接后，队列就会自动删除</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  绑定交换机与队列</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"等待接收消息，把接收到的消息打印在屏幕上..."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"01控制台打印接收到的消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReceiveLogs02</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消息的接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//创建一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个队列(临时队列)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 生成一个临时队列，队列名称是随机的</span></span><br><span class="line"><span class="comment">         * 当消费者断开连接后，队列就会自动删除</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  绑定交换机与队列</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"等待接收消息，把接收到的消息打印在屏幕上..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"02控制台打印接收到的消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消费者取消消息时，触发的接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>EmitLog</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 发消息 交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//控制台输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产者发出消息："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807230139017.png" alt="image-20210807230139017"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807230203065.png" alt="image-20210807230203065"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210807230215770.png" alt="image-20210807230215770"></p>
<h2 id="Direct-exchange"><a href="#Direct-exchange" class="headerlink" title="Direct exchange"></a>Direct exchange</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本 节我们将向其中添加一些特别的功能-比方说我们只让某个消费者订阅发布的部分消息。例如我们只把 严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</p>
<p>我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： <strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:<code>channel.queueBind(queueName, EXCHANGE_NAME, &quot;routingKey&quot;);</code><strong>绑定之后的 意义由其交换类型决定</strong>。</p>
<h3 id="Direct-exchange-介绍"><a href="#Direct-exchange-介绍" class="headerlink" title="Direct exchange 介绍"></a>Direct exchange 介绍</h3><p>我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808171543892.png" alt="image-20210808171543892"></p>
<p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green. </p>
<p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808171617166.png" alt="image-20210808171617166"></p>
<p>当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808171937258.png" alt="image-20210808171937258"></p>
<p>消息接收者1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"console"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//队列绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">"console"</span>, EXCHANGE_NAME, <span class="string">"info"</span>);</span><br><span class="line">        channel.queueBind(<span class="string">"console"</span>, EXCHANGE_NAME, <span class="string">"warning"</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"ReceiveLogsDirect01控制台接收消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">"console"</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息接收者2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsDirect02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明一个交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">"disk"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//队列绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">"disk"</span>, EXCHANGE_NAME, <span class="string">"error"</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"ReceiveLogsDirect02控制台接收消息："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(<span class="string">"disk"</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息发送者（根据指定routingKey来发送给消费者消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectLogs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"error"</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产者发出消息："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h3 id="类型的问题"><a href="#类型的问题" class="headerlink" title="类型的问题"></a>类型的问题</h3><p>改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志。</p>
<p>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型</p>
<h3 id="Topic-的要求"><a href="#Topic-的要求" class="headerlink" title="Topic 的要求"></a>Topic 的要求</h3><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单 词列表，以点号分隔开。这些单词可以是任意单词，比如说：”<code>stock.usd.nyse</code>“, “<code>nyse.vmw</code>“,  “<code>quick.orange.rabbit</code>“.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p>
<p>在这个规则列表中，其中有两个替换符是需要注意的 </p>
<ul>
<li><code>*</code>(星号)可以代替一个单词 </li>
<li><code>#</code>(井号)可以替代零个或多个单词</li>
</ul>
<h3 id="Topic-匹配案例"><a href="#Topic-匹配案例" class="headerlink" title="Topic 匹配案例"></a>Topic 匹配案例</h3><p>下图绑定关系如下 </p>
<p>Q1—&gt;绑定的是 中间带 orange 带 3 个单词的字符串(<em>.orange.</em>) </p>
<p>Q2—&gt;绑定的是 最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit)，第一个单词是 lazy 的多个单词(lazy.#)</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808174625649.png" alt="image-20210808174625649"></p>
<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的</p>
<p>quick.orange.rabbit                    被队列 Q1Q2 接收</p>
<p>lazy.orange.elephant                 被队列 Q1Q2 接收到</p>
<p>quick.orange.fox                         被队列 Q1 接收到 </p>
<p>lazy.brown.fox                             被队列 Q2 接收到 </p>
<p>lazy.pink.rabbit                           虽然满足两个绑定但只被队列 Q2 接收一次 </p>
<p>quick.brown.fox                          不匹配任何绑定不会被任何队列接收到会被丢弃 </p>
<p>quick.orange.male.rabbit         是四个单词不匹配任何绑定会被丢弃 </p>
<p>lazy.orange.male.rabbit            是四个单词但匹配 Q2</p>
<p>当队列绑定关系是下列这种情况时需要引起注意</p>
<ul>
<li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong> </li>
<li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li>
</ul>
<h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808184839685.png" alt="image-20210808184839685"></p>
<p>两个队列Q1,Q2</p>
<p>三个RoutingKey（Q1绑定一个，Q2绑定2个）</p>
<p>消息接收者1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 声明主题交换机 及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者C1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String queueName = <span class="string">"Q1"</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.orange.*"</span>);</span><br><span class="line">        System.out.println(<span class="string">"等待接收消息..."</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"接受队列："</span>+queueName+<span class="string">" RoutingKey 绑定键："</span>+message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息接收者2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 声明主题交换机 及相关队列</span></span><br><span class="line"><span class="comment"> * 消费者C2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        String queueName = <span class="string">"Q2"</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定两个</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.*.rabbit"</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"lazy.#"</span>);</span><br><span class="line">        System.out.println(<span class="string">"等待接收消息..."</span>);</span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"接受队列："</span>+queueName+<span class="string">" RoutingKey 绑定键："</span>+message.getEnvelope().getRoutingKey());</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息发送者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Q1--&gt;绑定的是 中间带 orange 带 3 个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">         * Q2--&gt;绑定的是 最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)，第一个单词是 lazy 的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        HashMap&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        bindingKeyMap.put(<span class="string">"quick.orange.rabbit"</span>, <span class="string">"被队列 Q1Q2 接收"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"lazy.orange.elephant"</span>, <span class="string">"被队列 Q1Q2 接收到"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"quick.orange.fox"</span>, <span class="string">"被队列 Q1 接收到"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"lazy.brown.fox"</span>, <span class="string">"被队列 Q2 接收到"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"lazy.pink.rabbit"</span>, <span class="string">"虽然满足两个绑定但只被队列 Q2 接收一次"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"quick.brown.fox"</span>, <span class="string">"不匹配任何绑定不会被任何队列接收到会被丢弃"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">"quick.orange.male.rabbit"</span>, <span class="string">"是四个单词不匹配任何绑定会被丢弃"</span>);</span><br><span class="line">        bindingKeyMap.put(<span class="string">" lazy.orange.male.rabbit"</span>, <span class="string">"是四个单词但匹配 Q2"</span>);</span><br><span class="line">        <span class="comment">//循环便利map中的key和value</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;</span><br><span class="line">            String routingKey = bindingKeyEntry.getKey();</span><br><span class="line">            String message = bindingKeyEntry.getValue();</span><br><span class="line">            <span class="comment">//将每一对消息发出</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产者发送消息："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808200129119.png" alt="image-20210808200129119"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808200153306.png" alt="image-20210808200153306"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808200204321.png" alt="image-20210808200204321"></p>
<h1 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h1><h2 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h2><p>死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<h2 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h2><ul>
<li>消息 TTL 过期 （存活时间）</li>
<li>队列达到最大长度(队列满了，无法再添加数据到 mq 中) </li>
<li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false</li>
</ul>
<h2 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h2><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210808200443436.png" alt="image-20210808200443436"></p>
<h3 id="消息-TTL-过期"><a href="#消息-TTL-过期" class="headerlink" title="消息 TTL 过期"></a>消息 TTL 过期</h3><h4 id="代码编写："><a href="#代码编写：" class="headerlink" title="代码编写："></a>代码编写：</h4><p>消息接收者C1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 死信队列    实战</span></span><br><span class="line"><span class="comment"> * 消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">"normal_exchange"</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE = <span class="string">"dead_exchange"</span>;</span><br><span class="line">    <span class="comment">//普通队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE = <span class="string">"normal_queue"</span>;</span><br><span class="line">    <span class="comment">//死信队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">"dead_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        <span class="comment">//声明死信和普通交换机，类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置普通队列参数</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//过期时间  10s=10000ms (由生产设置)</span></span><br><span class="line">        <span class="comment">//arguments.put("x-message-ttl", 10000);</span></span><br><span class="line">        <span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-exchange"</span>, DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"lisi"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明普通队列(设置参数使其成为死信队列)</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        <span class="comment">//声明死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定普通的交换机与普通的队列</span></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//绑定死信的交换机与死信的队列</span></span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">"lisi"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"等待接收消息..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTage, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Consumer01接收的消息是："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息接收者C2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 死信队列    实战</span></span><br><span class="line"><span class="comment"> * 消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE = <span class="string">"dead_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"等待接收消息..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTage, message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Consumer02接收的消息是："</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 死信队列    生产者代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">"normal_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//死信消息  设置TTL时间 设置10s</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">"10000"</span>).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"info"</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">"zhangsan"</span>, properties, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><p>生产者未发送消息时（启动消费者）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809112751082.png" alt="image-20210809112751082"></p>
<p>生产者发送消息时（断开消费者，启动生产者）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809112919647.png" alt="image-20210809112919647"></p>
<p>等待10s过后，未处理的消息传递到死信队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809115350958.png" alt="image-20210809115350958"></p>
<p>启动消费者2，将死信队列的消息处理掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809115229510.png" alt="image-20210809115229510"></p>
<p>C2控制台打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809115431420.png" alt="image-20210809115431420"></p>
<h4 id="遇见的问题："><a href="#遇见的问题：" class="headerlink" title="遇见的问题："></a>遇见的问题：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: <span class="comment">#method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'type' for exchange 'messageChange' in vhost '/': received 'fanout' but current is 'direct', class-id=40, method-id=10)</span></span><br></pre></td></tr></table></figure>
<p>（1）检查消费者代码：绑定队列与声明队列的顺序，（先声明队列，后绑定队列）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明普通队列(设置参数使其成为死信队列)</span></span><br><span class="line"> channel.queueDeclare(NORMAL_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"> <span class="comment">//绑定普通的交换机与普通的队列</span></span><br><span class="line"> channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">"zhangsan"</span>);</span><br></pre></td></tr></table></figure>
<p>（2）检查web界面用户权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809112545723.png" alt="image-20210809112545723"></p>
<p>修改一下即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809112619543.png" alt="image-20210809112619543"></p>
<h3 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h3><h4 id="代码编写：-1"><a href="#代码编写：-1" class="headerlink" title="代码编写："></a>代码编写：</h4><p>消息生产者代码去掉 TTL 属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE = <span class="string">"normal_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMQUtils.getChannel();</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//死信消息  设置TTL时间 设置10s</span></span><br><span class="line">        <span class="comment">//AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"info"</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE, <span class="string">"zhangsan"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置普通队列参数</span></span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//过期时间  10s=10000ms (由生产设置)</span></span><br><span class="line"><span class="comment">//arguments.put("x-message-ttl", 10000);</span></span><br><span class="line"><span class="comment">//正常队列设置死信交换机</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//设置死信RoutingKey</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"lisi"</span>);</span><br><span class="line"><span class="comment">//设置正常队列的长度限制</span></span><br><span class="line">arguments.put(<span class="string">"x-max-length"</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>C2消费者代码不变，直接执行即可</p>
<h4 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h4><p>开启消息发送者（关闭消息接收者C1）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809162910104.png" alt="image-20210809162910104"></p>
<p>开启消息接收者C2</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809163030071.png" alt="image-20210809163030071"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809163042529.png" alt="image-20210809163042529"></p>
<h3 id="消息被拒"><a href="#消息被拒" class="headerlink" title="消息被拒"></a>消息被拒</h3><h4 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h4><p>消息生产者代码同上生产者一致</p>
<p>消息接收者C1（启动之后关闭该消费者 模拟其接收不到消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DeliverCallback deliverCallback = (consumerTage, message) -&gt; &#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">if</span> (msg.equals(<span class="string">"info5"</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">"Consumer01接收的消息是："</span>+msg+<span class="string">"：此消息是被C1拒绝的"</span>);</span><br><span class="line">        channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Consumer01接收的消息是："</span>+msg);</span><br><span class="line">        <span class="comment">//开启手动应答，不进行自动批量处理</span></span><br><span class="line">        channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收消息 </span></span><br><span class="line"><span class="comment">//关闭自动应答</span></span><br><span class="line">channel.basicConsume(NORMAL_QUEUE, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>消息接收者C2不变</p>
<h4 id="结果展示：-1"><a href="#结果展示：-1" class="headerlink" title="结果展示："></a>结果展示：</h4><p>C1消息接收者</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809164418419.png" alt="image-20210809164418419"></p>
<p>C2消息接收者（死信接收）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809164453651.png" alt="image-20210809164453651"></p>
<p>有一个消息被拒绝，直接传递到死信队列中</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809164558162.png" alt="image-20210809164558162"></p>
<h1 id="7-延迟队列"><a href="#7-延迟队列" class="headerlink" title="7.延迟队列"></a>7.延迟队列</h1><h2 id="延迟队列概念"><a href="#延迟队列概念" class="headerlink" title="延迟队列概念"></a>延迟队列概念</h2><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<h2 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h2><ul>
<li>1.订单在十分钟之内未支付则自动取消 </li>
<li>2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </li>
<li>3.用户注册成功后，如果三天内没有登陆则进行短信提醒。 </li>
<li>4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。 </li>
<li>5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ul>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809165404441.png" alt="image-20210809165404441"></p>
<h2 id="RabbitMQ-中的-TTL"><a href="#RabbitMQ-中的-TTL" class="headerlink" title="RabbitMQ 中的 TTL"></a>RabbitMQ 中的 TTL</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间， 单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这 条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p>
<h3 id="消息设置-TTL"><a href="#消息设置-TTL" class="headerlink" title="消息设置 TTL"></a>消息设置 TTL</h3><p>针对每条消息设置 TTL</p>
<h3 id="队列设置-TTL"><a href="#队列设置-TTL" class="headerlink" title="队列设置 TTL"></a>队列设置 TTL</h3><p>在创建队列的时候设置队列的“x-message-ttl”属性</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。 </p>
<p>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已 经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延 时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为 里面的消息都是希望被立即处理的消息。</p>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><p>Pom依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ 测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.158.141</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>添加 Swagger 配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> *  Swagger文档</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">"webApi"</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"rabbitmq 接口文档"</span>)</span><br><span class="line">                .description(<span class="string">"本文档描述了 rabbitmq 微服务接口定义"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">"eternal0918"</span>, <span class="string">"http://zxp.com"</span>,</span><br><span class="line">                        <span class="string">"1728456478@qq.com"</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h2><h3 id="代码框架图"><a href="#代码框架图" class="headerlink" title="代码框架图"></a>代码框架图</h3><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809172732825.png" alt="image-20210809172732825"></p>
<h3 id="配置文件类"><a href="#配置文件类" class="headerlink" title="配置文件类"></a>配置文件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TtlQueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">"X"</span>;</span><br><span class="line">    <span class="comment">//死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">"Y"</span>;</span><br><span class="line">    <span class="comment">//普通队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_A = <span class="string">"QA"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_B = <span class="string">"QB"</span>;</span><br><span class="line">    <span class="comment">//死信队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUE = <span class="string">"QD"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明x交换机    别名</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"xExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明y交换机    别名</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"yExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列  TTL为 10s</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"queueA"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置参数(指定map初始化大小：初始map为3个长度，减少哈希表扩容操作)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-exchange"</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"YD"</span>);</span><br><span class="line">        <span class="comment">//设置TTL时间 10s</span></span><br><span class="line">        arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列  TTL为 40s</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"queueB"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置参数(指定map初始化大小：初始map为3个长度，减少哈希表扩容操作)</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-exchange"</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置RoutingKey</span></span><br><span class="line">        arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"YD"</span>);</span><br><span class="line">        <span class="comment">//设置TTL时间 10s</span></span><br><span class="line">        arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"queueD"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定普通队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABingdingX</span><span class="params">(@Qualifier(<span class="string">"queueA"</span>)</span> Queue queueA, @<span class="title">Qualifier</span><span class="params">(<span class="string">"xExchange"</span>)</span> DirectExchange xExchange) </span>&#123;</span><br><span class="line">        <span class="comment">//队列QA与交换机X进行绑定，并设置routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">"XA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定普通队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBingdingX</span><span class="params">(@Qualifier(<span class="string">"queueB"</span>)</span> Queue queueB, @<span class="title">Qualifier</span><span class="params">(<span class="string">"xExchange"</span>)</span> DirectExchange xExchange) </span>&#123;</span><br><span class="line">        <span class="comment">//队列QB与交换机X进行绑定，并设置routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">"XB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBingdingY</span><span class="params">(@Qualifier(<span class="string">"queueD"</span>)</span> Queue queueD, @<span class="title">Qualifier</span><span class="params">(<span class="string">"yExchange"</span>)</span> DirectExchange yExchange) </span>&#123;</span><br><span class="line">        <span class="comment">//队列QD与交换机Y进行绑定，并设置routingKey</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">"YD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 发送延迟消息</span></span><br><span class="line"><span class="comment"> * http://localhost:8080/ttl/sendMsg/张三</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/ttl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息模板</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sendMsg/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自动替换括号：   时间替换掉第一个&#123;&#125;      信息替换掉第二个&#123;&#125;</span></span><br><span class="line">        log.info(<span class="string">"当前时间：&#123;&#125;，发送一条信息给两个TTL队列：&#123;&#125;"</span>, <span class="keyword">new</span> Date().toString(), message);</span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"X"</span>, <span class="string">"XA"</span>, <span class="string">"消息来自TTL为10s的队列:"</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"X"</span>, <span class="string">"XB"</span>, <span class="string">"消息来自TTL为40s的队列:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息接收者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 队列TTL   消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"QD"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">"当前时间：&#123;&#125;，收到死信队列的消息：&#123;&#125;"</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果展示-1"><a href="#结果展示-1" class="headerlink" title="结果展示"></a>结果展示</h3><p>在浏览器中发送一个请求</p>
<p><code>http://localhost:8080/ttl/sendMsg/张三</code></p>
<p>控制台打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809194735432.png" alt="image-20210809194735432"></p>
<h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><p>如果出现发送消息后，接收不到，通过web管理界面检查一下是否绑定成功，未绑定成功的，检查一下绑定代码的是否有误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。</p>
<p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然 后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
<h2 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h2><h3 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h3><p>新增了一个队列 QC,绑定关系如下,该队列不设置 TTL 时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809195128901.png" alt="image-20210809195128901"></p>
<h3 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增一个普通队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_C = <span class="string">"QC"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为新增的普通队列声明</span></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"queueC"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queueC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置参数(指定map初始化大小：初始map为3个长度，减少哈希表扩容操作)</span></span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置死信交换机</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    <span class="comment">//设置RoutingKey</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"YD"</span>);</span><br><span class="line">    <span class="comment">//该队列不设置ttl时间</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为新增的队列进行绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">queueCBingdingX</span><span class="params">(@Qualifier(<span class="string">"queueC"</span>)</span> Queue queueC, @<span class="title">Qualifier</span><span class="params">(<span class="string">"xExchange"</span>)</span> DirectExchange xExchange) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">"XC"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为新增的队列QC发消息 和 TTL时间</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(@PathVariable String message, @PathVariable String ttlTime)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;"</span>, <span class="keyword">new</span> Date(), ttlTime, message);</span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"X"</span>, <span class="string">"XC"</span>, message, msg -&gt; &#123;</span><br><span class="line">        <span class="comment">//发送消息的时候，延迟时长</span></span><br><span class="line">        msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><p>发送请求</p>
<p><code>http://localhost:8080/ttl/sendExpirationMsg/你好01/20000</code></p>
<p><code>http://localhost:8080/ttl/sendExpirationMsg/你好02/2000</code></p>
<h3 id="结果展示-2"><a href="#结果展示-2" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809201624139.png" alt="image-20210809201624139"></p>
<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消 息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p>
<p><strong>简而言之</strong>：若延迟时间长的在第一个，那么后续即使延迟时间再短也要等第一个长时间的到达，才会将消息进行执行</p>
<h2 id="Rabbitmq-插件实现延迟队列"><a href="#Rabbitmq-插件实现延迟队列" class="headerlink" title="Rabbitmq 插件实现延迟队列"></a>Rabbitmq 插件实现延迟队列</h2><p>如果不能实现在消息力度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。该问题可以通过Rabbitmq 插件实现延迟队列进行解决</p>
<h3 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h3><p>在官网上下载 <a href="https://www.rabbitmq.com/community-plugins.html，下载" target="_blank" rel="noopener">https://www.rabbitmq.com/community-plugins.html，下载</a> rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。</p>
<p>进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行生效命令</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启RabbitMQ服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>添加完插件重启后（添加交换机）</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809203857264.png" alt="image-20210809203857264"></p>
<h3 id="实现延迟原理"><a href="#实现延迟原理" class="headerlink" title="实现延迟原理"></a>实现延迟原理</h3><h3 id="代码架构图-2"><a href="#代码架构图-2" class="headerlink" title="代码架构图"></a>代码架构图</h3><p>在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809204400812.png" alt="image-20210809204400812"></p>
<h4 id="配置文件类-1"><a href="#配置文件类-1" class="headerlink" title="配置文件类"></a>配置文件类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.CustomExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">"delayed.queue"</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">"delayed.exchange"</span>;</span><br><span class="line">    <span class="comment">//routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">"delayed.routingkey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.交换机的名称</span></span><br><span class="line"><span class="comment">         * 2.交换机的类型</span></span><br><span class="line"><span class="comment">         * 3.是否需要持久化</span></span><br><span class="line"><span class="comment">         * 4.是否需要自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">"x-delayed-message"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayedQueueBindingDelayedExchange</span><span class="params">(@Qualifier(<span class="string">"delayedQueue"</span>)</span> Queue delayedQueue, @<span class="title">Qualifier</span><span class="params">(<span class="string">"delayedExchange"</span>)</span> CustomExchange delayedExchange) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息生产者-2"><a href="#消息生产者-2" class="headerlink" title="消息生产者"></a>消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始发消息 基于插件    消息及延迟的时间</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(@PathVariable String message, @PathVariable Integer delayTime)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">" 当前时间:&#123;&#125;, 发送一条延迟&#123;&#125;毫秒的信息给队列 delayed.queue:&#123;&#125;"</span>, <span class="keyword">new</span> Date(), delayTime, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message, msg -&gt; &#123;</span><br><span class="line">        <span class="comment">//发送消息的时候，延迟时长，单位ms</span></span><br><span class="line">        msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 消费者 基于插件的延迟消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听消息</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveDelayQueue</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">"当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;"</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程序执行-1"><a href="#程序执行-1" class="headerlink" title="程序执行"></a>程序执行</h4><p>发起请求： </p>
<p><code>http://localhost:8080/ttl/sendDelayMsg/come on baby1/20000</code></p>
<p><code>http://localhost:8080/ttl/sendDelayMsg/come on baby2/2000</code></p>
<h4 id="结果展示-3"><a href="#结果展示-3" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210809211203882.png" alt="image-20210809211203882"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。 </p>
<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>
<h1 id="8-发布确认高级"><a href="#8-发布确认高级" class="headerlink" title="8.发布确认高级"></a>8.发布确认高级</h1><p>在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ 特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-1516:36:04] 发 生 [ 错误日志异常 ] ， alertId=[xxx] 。 由</span><br><span class="line">[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620] 触发。 </span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服务名为： </span><br><span class="line">异常为： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620, </span><br><span class="line">产 生 原 因 如 下 :1.org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: </span><br><span class="line">Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">'t exist or the broker will not </span></span><br><span class="line"><span class="string">allow us to use it.||Consumer received fatal=false exception on startup:</span></span><br></pre></td></tr></table></figure>
<h2 id="发布确认-springboot-版本"><a href="#发布确认-springboot-版本" class="headerlink" title="发布确认 springboot 版本"></a>发布确认 springboot 版本</h2><h3 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810103351553.png" alt="image-20210810103351553"></p>
<h3 id="代码架构图-3"><a href="#代码架构图-3" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810103406388.png" alt="image-20210810103406388"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在配置文件中添加</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.158.141</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新添加的</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure>
<ul>
<li>NONE         禁用发布确认模式，是默认值 </li>
<li>CORRELATED         发布消息成功到交换器后会触发回调方法 </li>
<li>SIMPLE         经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法， 其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法 等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。<strong>建议不用（类似于单个确认，效率低下）</strong></li>
</ul>
<h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">"confirm_exchange"</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">"confirm_queue"</span>;</span><br><span class="line">    <span class="comment">//RoutingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_ROUTING_KEY = <span class="string">"key1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机声明</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"confirmExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"confirmQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBindingExchange</span><span class="params">(@Qualifier(<span class="string">"confirmQueue"</span>)</span> Queue confirmQueue, @<span class="title">Qualifier</span><span class="params">(<span class="string">"confirmExchange"</span>)</span> DirectExchange confirmExchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息生产者-3"><a href="#消息生产者-3" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * //开始发消息 测试确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/confirm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sendMessage/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData=<span class="keyword">new</span> CorrelationData(<span class="string">"1"</span>);</span><br><span class="line">        log.info(<span class="string">"发送消息内容：&#123;&#125;"</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, message,correlationData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *   1.发消息   交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *       1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       1.2 交换机收到消息      ack = true</span></span><br><span class="line"><span class="comment">     *       1.3 cause   null</span></span><br><span class="line"><span class="comment">     *   2.发消息   交换机接受失败了    回调</span></span><br><span class="line"><span class="comment">     *       2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       2.2 交换机接收到消息    ack = false</span></span><br><span class="line"><span class="comment">     *       2.3 cause   失败的原因</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">"交换机已经收到ID:&#123;&#125;的消息"</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"交换机尚未收到ID:&#123;&#125;的消息,由于原因：&#123;&#125;"</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息消费者-2"><a href="#消息消费者-2" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfirmMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">"接受到队列 confirm.queue 消息:&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序执行-2"><a href="#程序执行-2" class="headerlink" title="程序执行"></a>程序执行</h3><p>浏览器输入：</p>
<p><code>http://localhost:8080/confirm/sendMessage/张三</code></p>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p>正常情况下</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810175251709.png" alt="image-20210810175251709"></p>
<p>交换机不存在的情况下</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810175645021.png" alt="image-20210810175645021"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: 发送消息内容：张三</span><br><span class="line">: Shutdown Signal: channel error; protocol method: <span class="comment">#method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'confirm_exchange111' in vhost '/', class-id=60, method-id=40)</span></span><br><span class="line">: 交换机尚未收到ID:1的消息,由于原因：channel error; protocol method: <span class="comment">#method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange 'confirm_exchange111' in vhost '/', class-id=60, method-id=40)</span></span><br></pre></td></tr></table></figure>
<p>为一个不存在的队列发送消息</p>
<p>修改一下发送者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发消息</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sendMessage/&#123;message&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">"1"</span>);</span><br><span class="line">    log.info(<span class="string">"key1发送消息内容：&#123;&#125;"</span>, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData1);</span><br><span class="line">    </span><br><span class="line">    CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">"2"</span>);</span><br><span class="line">    log.info(<span class="string">"key2发送消息内容：&#123;&#125;"</span>, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">"1"</span>, message, correlationData2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810180300803.png" alt="image-20210810180300803"></p>
<p>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为 第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条 消息被直接丢弃了。</p>
<h2 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h2><h3 id="Mandatory-参数"><a href="#Mandatory-参数" class="headerlink" title="Mandatory 参数"></a>Mandatory 参数</h3><p><strong>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如 果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。</strong></p>
<p>那么如何 让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参 数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<h3 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/confirm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sendMessage/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存在的routingkey</span></span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">"1"</span>);</span><br><span class="line">        log.info(<span class="string">"key1发送消息内容：&#123;&#125;"</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData1);</span><br><span class="line">        <span class="comment">//不存在的routingkey</span></span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">"2"</span>);</span><br><span class="line">        log.info(<span class="string">"key2发送消息内容：&#123;&#125;"</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">"1"</span>, message, correlationData2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回调接口-1"><a href="#回调接口-1" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnsCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将ConfirmCallback注入到容器中</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//将ReturnsCallback注入到容器中</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *   1.发消息   交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *       1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       1.2 交换机收到消息      ack = true</span></span><br><span class="line"><span class="comment">     *       1.3 cause   null</span></span><br><span class="line"><span class="comment">     *   2.发消息   交换机接受失败了    回调</span></span><br><span class="line"><span class="comment">     *       2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       2.2 交换机接收到消息    ack = false</span></span><br><span class="line"><span class="comment">     *       2.3 cause   失败的原因</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">"交换机已经收到ID:&#123;&#125;的消息"</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"交换机尚未收到ID:&#123;&#125;的消息,由于原因：&#123;&#125;"</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在当前消息传递过程中不可达到目的地时将消息返回给生产者</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只有不可达到目的地时，才会进行回退    （发消息找不到指定的routingkey后就将消息返回给发送方）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因：&#123;&#125;，路由Key：&#123;&#125;"</span>, <span class="keyword">new</span> String(returnedMessage.getMessage().getBody()), returnedMessage.getExchange(),</span><br><span class="line">                returnedMessage.getReplyText(), returnedMessage.getRoutingKey());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序执行-3"><a href="#程序执行-3" class="headerlink" title="程序执行"></a>程序执行</h3><p>同上面操作一样</p>
<h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810183856425.png" alt="image-20210810183856425"></p>
<p>发送给不存在的Key2（RoutingKey：key11）消息后，通过交换机进行退回给原发送方</p>
<h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><p>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息 无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然 后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者 所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增 加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的 复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些 处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份 交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时， 就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由 备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑 定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都 进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>
<h3 id="代码架构图-4"><a href="#代码架构图-4" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810193852849.png" alt="image-20210810193852849"></p>
<h3 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE_NAME = <span class="string">"confirm_exchange"</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE_NAME = <span class="string">"confirm_queue"</span>;</span><br><span class="line">    <span class="comment">//RoutingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_ROUTING_KEY = <span class="string">"key1"</span>;</span><br><span class="line">    <span class="comment">//备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_EXCHANGE_NAME = <span class="string">"backup_exchange"</span>;</span><br><span class="line">    <span class="comment">//备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACKUP_QUEUE_NAME = <span class="string">"backup_queue"</span>;</span><br><span class="line">    <span class="comment">//报警队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE_NAME = <span class="string">"warning_queue"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机声明</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"confirmExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="keyword">true</span>).withArgument(<span class="string">"alternate-exchange"</span>, BACKUP_EXCHANGE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列声明</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"confirmQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBindingExchange</span><span class="params">(@Qualifier(<span class="string">"confirmQueue"</span>)</span> Queue confirmQueue, @<span class="title">Qualifier</span><span class="params">(<span class="string">"confirmExchange"</span>)</span> DirectExchange confirmExchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份交换机声明</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"backExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACKUP_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"backQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报警队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"warningQueue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backQueueBindingBackExchange</span><span class="params">(@Qualifier(<span class="string">"backQueue"</span>)</span> Queue backQueue,</span></span><br><span class="line"><span class="function">                                                @<span class="title">Qualifier</span><span class="params">(<span class="string">"backExchange"</span>)</span> FanoutExchange backExchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backQueue).to(backExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//报警队列绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">waringQueueBindingBackExchange</span><span class="params">(@Qualifier(<span class="string">"warningQueue"</span>)</span> Queue warningQueue,</span></span><br><span class="line"><span class="function">                                                  @<span class="title">Qualifier</span><span class="params">(<span class="string">"backExchange"</span>)</span> FanoutExchange backExchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 报警消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaringConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收报警消息</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = ConfirmConfig.WARNING_QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveWarningMsg</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg=<span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">"报警发现不可路由消息：&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通消费者"><a href="#普通消费者" class="headerlink" title="普通消费者"></a>普通消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = ConfirmConfig.CONFIRM_QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfirmMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">"接受到队列 confirm.queue 消息:&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息发送者"><a href="#消息发送者" class="headerlink" title="消息发送者"></a>消息发送者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * //开始发消息 测试确认</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/confirm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sendMessage/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData1 = <span class="keyword">new</span> CorrelationData(<span class="string">"1"</span>);</span><br><span class="line">        log.info(<span class="string">"key1发送消息内容：&#123;&#125;"</span>, message+<span class="string">"key1"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData1);</span><br><span class="line">        </span><br><span class="line">        CorrelationData correlationData2 = <span class="keyword">new</span> CorrelationData(<span class="string">"2"</span>);</span><br><span class="line">        log.info(<span class="string">"key2发送消息内容：&#123;&#125;"</span>, message+<span class="string">"key2"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE_NAME, ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">"1"</span>, message, correlationData2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回调接口-2"><a href="#回调接口-2" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnsCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将ConfirmCallback注入到容器中</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//将ReturnsCallback注入到容器中</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   交换机确认回调方法</span></span><br><span class="line"><span class="comment">     *   1.发消息   交换机接收到了 回调</span></span><br><span class="line"><span class="comment">     *       1.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       1.2 交换机收到消息      ack = true</span></span><br><span class="line"><span class="comment">     *       1.3 cause   null</span></span><br><span class="line"><span class="comment">     *   2.发消息   交换机接受失败了    回调</span></span><br><span class="line"><span class="comment">     *       2.1 correlationData 保存回调消息的ID及相关消息</span></span><br><span class="line"><span class="comment">     *       2.2 交换机接收到消息    ack = false</span></span><br><span class="line"><span class="comment">     *       2.3 cause   失败的原因</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">"交换机已经收到ID:&#123;&#125;的消息"</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"交换机尚未收到ID:&#123;&#125;的消息,由于原因：&#123;&#125;"</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在当前消息传递过程中不可达到目的地时将消息返回给生产者</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只有不可达到目的地时，才会进行回退    （发消息找不到指定的routingkey后就将消息返回给发送方）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"消息&#123;&#125;，被交换机&#123;&#125;退回，退回原因：&#123;&#125;，路由Key：&#123;&#125;"</span>, <span class="keyword">new</span> String(returnedMessage.getMessage().getBody()), returnedMessage.getExchange(),</span><br><span class="line">                returnedMessage.getReplyText(), returnedMessage.getRoutingKey());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序执行-4"><a href="#程序执行-4" class="headerlink" title="程序执行"></a>程序执行</h3><p>同上面的操作</p>
<h3 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810202103050.png" alt="image-20210810202103050"></p>
<p>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先 级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</p>
<h1 id="9-RabbitMQ其他知识"><a href="#9-RabbitMQ其他知识" class="headerlink" title="9.RabbitMQ其他知识"></a>9.RabbitMQ其他知识</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误 立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等</p>
<h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但 实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费 者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消 息时用该 id 先判断该消息是否已消费过。</p>
<h3 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h3><p>在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。</p>
<p><strong>业界主流的幂等性有两种操作:</strong></p>
<ul>
<li>a. 唯一 ID+指纹码机制,利用数据库主键去重,</li>
<li>b.利用 redis 的原子性去实现</li>
</ul>
<h3 id="唯一-ID-指纹码机制"><a href="#唯一-ID-指纹码机制" class="headerlink" title="唯一 ID+指纹码机制"></a>唯一 ID+指纹码机制</h3><p>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基 本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存 在数据库中,优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数 据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。</p>
<h3 id="Redis-原子性"><a href="#Redis-原子性" class="headerlink" title="Redis 原子性"></a>Redis 原子性</h3><p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如 果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创 造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存 放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景， 所以订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810203639726.png" alt="image-20210810203639726"></p>
<h3 id="添加优先级队列"><a href="#添加优先级队列" class="headerlink" title="添加优先级队列"></a>添加优先级队列</h3><p>控制台页面添加</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810203305242.png" alt="image-20210810203305242"></p>
<p>队列中代码添加优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap();</span><br><span class="line">params.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"hello"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810204519016.png" alt="image-20210810204519016"></p>
<p>消息中代码添加优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 鸿雁</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 生产者 ： 发消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//工厂IP连接RabbitMQ的队列</span></span><br><span class="line">        factory.setHost(<span class="string">"192.168.158.141"</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  生成一个队列</span></span><br><span class="line"><span class="comment">         *  1.队列名称 QUEUE_NAME</span></span><br><span class="line"><span class="comment">         *  2.队列里面的消息是否持久化（存储在磁盘），默认情况消息存储在内存中</span></span><br><span class="line"><span class="comment">         *  3.该队列是否只供一个消费者进行消费，是否进行消息共享true可以多个消费者消费，false只能一个消费者消费</span></span><br><span class="line"><span class="comment">         *  4.是否自动删除，最后一个消费者端开连接以后，该队列一句是否自动删除，true自动删除，false不自动删除</span></span><br><span class="line"><span class="comment">         *  5.其他参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//官方允许 0-255之间  此处设置10  允许优先级为0-10  不要设置过大，浪费CPU和内存</span></span><br><span class="line">        arguments.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);    </span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line"><span class="comment">//        String message = "Hello World";</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"info"</span> + i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">//消息设置优先级</span></span><br><span class="line">                AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  发送一个消费</span></span><br><span class="line"><span class="comment">         *  1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         *  2.路由的Key值是哪个</span></span><br><span class="line"><span class="comment">         *  3.其他参数信息</span></span><br><span class="line"><span class="comment">         *  4.发送消息的信息体</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        System.out.println(<span class="string">"发送消息完毕！"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果-3"><a href="#执行结果-3" class="headerlink" title="执行结果"></a>执行结果</h3><p>发送10条消息，其中消息5是优先级最高的</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810204835368.png" alt="image-20210810204835368"></p>
<p><strong>注意事项</strong></p>
<p>要让队列实现优先级需要做的事情有如下事情:队列需要设置为优先级队列，消息需要设置消息的优先 级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序</p>
<h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消 费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持 更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致 使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p>
<p>默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留 一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的 时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。</p>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>队列具备两种模式：<strong>default</strong> 和 <strong>lazy</strong>。</p>
<p>默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。</p>
<p>lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 </p>
<p>如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。</p>
<p>在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示 例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">"x-queue-mode"</span>, <span class="string">"lazy"</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"myqueue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure>
<h3 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h3><p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810205512298.png" alt="image-20210810205512298"></p>
<p>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB（这里存放在内存中的是索引），消息都存放在了磁盘上。惰性队列耗时长，不建议使用（除非消息特别大的时候）</p>
<h1 id="10-RabbitMQ-集群"><a href="#10-RabbitMQ-集群" class="headerlink" title="10.RabbitMQ 集群"></a>10.RabbitMQ 集群</h1><h2 id="clustering"><a href="#clustering" class="headerlink" title="clustering"></a>clustering</h2><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><p>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的 要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞 吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是 解决实际问题的关键.</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810210014542.png" alt="image-20210810210014542"></p>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1.修改 3 台机器的主机名称</span><br><span class="line">vim /etc/hostname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.配置各个节点的hosts文件，让各个节点都能互相识别对方</span><br><span class="line">vim /etc/hosts</span><br><span class="line">192.168.158.141 node01</span><br><span class="line">192.168.158.138 node02</span><br><span class="line">192.168.158.139 node03</span><br><span class="line">192.168.158.140 node04</span><br><span class="line"></span><br><span class="line">其余的主机安装好RabbitMQ并设置开机自启，开启web管理插件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.以确保各个节点的 cookie 文件使用的是同一个值</span><br><span class="line">在 node1 上执行远程操作命令</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node02:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node03:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node04:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line"></span><br><span class="line">4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在四台节点上分别执行以</span><br><span class="line">下命令)</span><br><span class="line">systemctl restart rabbitmq-server.service</span><br><span class="line">systemctl status rabbitmq-server.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.在节点 2 执行</span><br><span class="line"></span><br><span class="line">(rabbitmqctl stop 会将 Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node01</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">(rabbitmqctl start_app只启动应用服务)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.在节点 3 执行</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node02</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line">7.在节点 4 执行</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node03</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line">8.集群状态</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9.需要重新设置用户</span><br><span class="line">创建账号</span><br><span class="line">rabbitmqctl add_user admin 123</span><br><span class="line">设置用户角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line">设置用户权限</span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.解除集群节点(node2 和 node3 机器分别执行)</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810223627786.png" alt="image-20210810223627786"></p>
<h2 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h2><p>使用镜像的原因 </p>
<p>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true， 但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在 一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘， 尽管如此，一般不希望遇到因单点故障导致的服务不可用。</p>
<p><strong>引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。</strong></p>
<h3 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p>1.四台主机启动</p>
<p>2.随便找一台主机访问web管理界面对用户添加policy</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810225116639.png" alt="image-20210810225116639"></p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810225054123.png" alt="image-20210810225054123"></p>
<p>3.在 node1 上创建一个队列发送一条消息，队列存在镜像队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810225149902.png" alt="image-20210810225149902"></p>
<p>4.停掉 node1 之后发现 node2 成为镜像队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/eternal0918/mdimages.github.io/img/image-20210810225214482.png" alt="image-20210810225214482"></p>
<p>5.就算整个集群只剩下一台机器了 依然能消费队列里面的消息（自动备份到其他主机上）</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/08/30/单机Linux搭建Nacos集群/" data-toggle="tooltip" data-placement="top" title="单机Linux搭建Nacos集群">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2021/08/04/Docker-学习/" data-toggle="tooltip" data-placement="top" title="Docker 学习">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        This is copyright.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                
<link rel="stylesheet" href="/css/music-player/fonts/iconfont.css">


<link rel="stylesheet" href="/css/music-player/css/reset.css">


<link rel="stylesheet" href="/css/music-player/css/player.css">


<div class="music-player">
    <audio class="music-player__audio" ></audio>
    <div class="music-player__main">
        <div class="music-player__blur"></div>
        <div class="music-player__disc">
            <div class="music-player__image">
                <img width="100%" src="" alt="">
            </div>
            <div class="music-player__pointer"><img width="100%" src="/img/cd_tou.png" alt=""></div>
        </div>
        <div class="music-player__controls">
            <div class="music__info">
                <h3 class="music__info--title">...</h3>
                <p class="music__info--singer">...</p>
            </div>
            <div class="player-control">
                <div class="player-control__content">
                    <div class="player-control__btns">
                        <div class="player-control__btn player-control__btn--prev"><i class="iconfont icon-prev"></i></div>
                        <div class="player-control__btn player-control__btn--play"><i class="iconfont icon-play"></i></div>
                        <div class="player-control__btn player-control__btn--next"><i class="iconfont icon-next"></i></div>
                        <div class="player-control__btn player-control__btn--mode"><i class="iconfont icon-loop"></i></div>
                    </div>
                    <div class="player-control__volume">
                        <div class="control__volume--icon player-control__btn"><i class="iconfont icon-volume"></i></div>
                        <div class="control__volume--progress player_progress"></div>
                    </div>
                </div>
                <div class="player-control__content">
                    <div class="player__song--progress player_progress"></div>
                    <div class="player__song--timeProgess nowTime">00:00</div>
                    <div class="player__song--timeProgess totalTime">00:00</div>
                </div>
            </div>
        </div>
    </div>
</div>


<script src="/js/music-player/utill.js"></script>


<script src="/js/music-player/jquery.min.js"></script>

<!-- netease; qqkg -->
<!--
<script src="/js/music-player/player.js?library=config.music.library.js"></script>
-->
<script src="../../../../js/music-player/player.js?library=netease&music=https://music.163.com/#/playlist?id=5380610670&userid=340389419"></script>
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-消息队列"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1.消息队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MQ的相关概念"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">MQ的相关概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#什么是MQ"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">什么是MQ</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#为什么要用MQ"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">为什么要用MQ</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-流量削峰"><span class="toc-nav-number">1.1.2.1.</span> <span class="toc-nav-text">1.流量削峰</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-应用解耦"><span class="toc-nav-number">1.1.2.2.</span> <span class="toc-nav-text">2.应用解耦</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-异步处理"><span class="toc-nav-number">1.1.2.3.</span> <span class="toc-nav-text">3.异步处理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MQ的分类"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">MQ的分类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-ActiveMQ"><span class="toc-nav-number">1.1.3.1.</span> <span class="toc-nav-text">1.ActiveMQ</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-Kafka"><span class="toc-nav-number">1.1.3.2.</span> <span class="toc-nav-text">2.Kafka</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-RocketMQ"><span class="toc-nav-number">1.1.3.3.</span> <span class="toc-nav-text">3.RocketMQ</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-RabbitMQ"><span class="toc-nav-number">1.1.3.4.</span> <span class="toc-nav-text">4.RabbitMQ</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MQ的选择"><span class="toc-nav-number">1.1.4.</span> <span class="toc-nav-text">MQ的选择</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-Kafka"><span class="toc-nav-number">1.1.4.1.</span> <span class="toc-nav-text">1.Kafka</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-RocketMQ"><span class="toc-nav-number">1.1.4.2.</span> <span class="toc-nav-text">2.RocketMQ</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-RabbitMQ"><span class="toc-nav-number">1.1.4.3.</span> <span class="toc-nav-text">3.RabbitMQ</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RabbitMQ"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">RabbitMQ</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RabbitMQ-的概念"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">RabbitMQ 的概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#四大核心概念"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">四大核心概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RabbitMQ-核心部分"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">RabbitMQ 核心部分</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#各个名词介绍"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">各个名词介绍</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#安装-RabbitMQ"><span class="toc-nav-number">1.2.5.</span> <span class="toc-nav-text">安装 RabbitMQ</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动服务出现的问题"><span class="toc-nav-number">1.2.6.</span> <span class="toc-nav-text">启动服务出现的问题</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-Hello-World"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.Hello World</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Pom依赖"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Pom依赖</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消息生产者"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">消息生产者</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消息消费者"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">消息消费者</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3-Work-Queues"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3.Work Queues</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#轮询分发消息"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">轮询分发消息</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#抽取工具类"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">抽取工具类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动两个工作线程"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">启动两个工作线程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#启动一个发送线程"><span class="toc-nav-number">3.1.3.</span> <span class="toc-nav-text">启动一个发送线程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#结果展示"><span class="toc-nav-number">3.1.4.</span> <span class="toc-nav-text">结果展示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消息应答"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">消息应答</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#概念"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#自动应答"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">自动应答</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息应答的方法"><span class="toc-nav-number">3.2.3.</span> <span class="toc-nav-text">消息应答的方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Multiple的解释"><span class="toc-nav-number">3.2.4.</span> <span class="toc-nav-text">Multiple的解释</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息自动重新入队"><span class="toc-nav-number">3.2.5.</span> <span class="toc-nav-text">消息自动重新入队</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息手动应答代码"><span class="toc-nav-number">3.2.6.</span> <span class="toc-nav-text">消息手动应答代码</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#手动应答效果演示"><span class="toc-nav-number">3.2.7.</span> <span class="toc-nav-text">手动应答效果演示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RabbitMQ持久化"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">RabbitMQ持久化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#概念-1"><span class="toc-nav-number">3.3.1.</span> <span class="toc-nav-text">概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#队列如何实现持久化"><span class="toc-nav-number">3.3.2.</span> <span class="toc-nav-text">队列如何实现持久化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息实现持久化"><span class="toc-nav-number">3.3.3.</span> <span class="toc-nav-text">消息实现持久化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#不公平分发"><span class="toc-nav-number">3.3.4.</span> <span class="toc-nav-text">不公平分发</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#预取值"><span class="toc-nav-number">3.3.5.</span> <span class="toc-nav-text">预取值</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4-发布确认"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4.发布确认</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#发布确认原理"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">发布确认原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#发布确认的策略"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">发布确认的策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#开启发布确认的方法"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">开启发布确认的方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#单个确认发布"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text">单个确认发布</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#批量确认发布"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text">批量确认发布</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#异步确认发布"><span class="toc-nav-number">4.2.4.</span> <span class="toc-nav-text">异步确认发布</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何处理异步未确认消息"><span class="toc-nav-number">4.2.5.</span> <span class="toc-nav-text">如何处理异步未确认消息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-种发布确认速度对比"><span class="toc-nav-number">4.2.6.</span> <span class="toc-nav-text">3 种发布确认速度对比</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#5-交换机"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. 交换机</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Exchanges"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">Exchanges</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Exchanges-概念"><span class="toc-nav-number">5.1.1.</span> <span class="toc-nav-text">Exchanges 概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Exchanges-的类型"><span class="toc-nav-number">5.1.2.</span> <span class="toc-nav-text">Exchanges 的类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#无名-exchange"><span class="toc-nav-number">5.1.3.</span> <span class="toc-nav-text">无名 exchange</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#临时队列"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">临时队列</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#绑定（bindings）"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">绑定（bindings）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Fanout"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text">Fanout</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Fanout-介绍"><span class="toc-nav-number">5.4.1.</span> <span class="toc-nav-text">Fanout 介绍</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Fanout-实战"><span class="toc-nav-number">5.4.2.</span> <span class="toc-nav-text">Fanout 实战</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Direct-exchange"><span class="toc-nav-number">5.5.</span> <span class="toc-nav-text">Direct exchange</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#回顾"><span class="toc-nav-number">5.5.1.</span> <span class="toc-nav-text">回顾</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Direct-exchange-介绍"><span class="toc-nav-number">5.5.2.</span> <span class="toc-nav-text">Direct exchange 介绍</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#多重绑定"><span class="toc-nav-number">5.5.3.</span> <span class="toc-nav-text">多重绑定</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实战"><span class="toc-nav-number">5.5.4.</span> <span class="toc-nav-text">实战</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Topics"><span class="toc-nav-number">5.6.</span> <span class="toc-nav-text">Topics</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#类型的问题"><span class="toc-nav-number">5.6.1.</span> <span class="toc-nav-text">类型的问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Topic-的要求"><span class="toc-nav-number">5.6.2.</span> <span class="toc-nav-text">Topic 的要求</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Topic-匹配案例"><span class="toc-nav-number">5.6.3.</span> <span class="toc-nav-text">Topic 匹配案例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实战-1"><span class="toc-nav-number">5.6.4.</span> <span class="toc-nav-text">实战</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#6-死信队列"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6.死信队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#死信的概念"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">死信的概念</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#死信的来源"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">死信的来源</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#死信实战"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">死信实战</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码架构图"><span class="toc-nav-number">6.3.1.</span> <span class="toc-nav-text">代码架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息-TTL-过期"><span class="toc-nav-number">6.3.2.</span> <span class="toc-nav-text">消息 TTL 过期</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#代码编写："><span class="toc-nav-number">6.3.2.1.</span> <span class="toc-nav-text">代码编写：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#执行结果："><span class="toc-nav-number">6.3.2.2.</span> <span class="toc-nav-text">执行结果：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#遇见的问题："><span class="toc-nav-number">6.3.2.3.</span> <span class="toc-nav-text">遇见的问题：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#队列达到最大长度"><span class="toc-nav-number">6.3.3.</span> <span class="toc-nav-text">队列达到最大长度</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#代码编写：-1"><span class="toc-nav-number">6.3.3.1.</span> <span class="toc-nav-text">代码编写：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#结果展示："><span class="toc-nav-number">6.3.3.2.</span> <span class="toc-nav-text">结果展示：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息被拒"><span class="toc-nav-number">6.3.4.</span> <span class="toc-nav-text">消息被拒</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#代码展示："><span class="toc-nav-number">6.3.4.1.</span> <span class="toc-nav-text">代码展示：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#结果展示：-1"><span class="toc-nav-number">6.3.4.2.</span> <span class="toc-nav-text">结果展示：</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#7-延迟队列"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">7.延迟队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#延迟队列概念"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">延迟队列概念</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#延迟队列使用场景"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">延迟队列使用场景</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RabbitMQ-中的-TTL"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">RabbitMQ 中的 TTL</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息设置-TTL"><span class="toc-nav-number">7.3.1.</span> <span class="toc-nav-text">消息设置 TTL</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#队列设置-TTL"><span class="toc-nav-number">7.3.2.</span> <span class="toc-nav-text">队列设置 TTL</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#两者的区别"><span class="toc-nav-number">7.3.3.</span> <span class="toc-nav-text">两者的区别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#整合SpringBoot"><span class="toc-nav-number">7.4.</span> <span class="toc-nav-text">整合SpringBoot</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#队列TTL"><span class="toc-nav-number">7.5.</span> <span class="toc-nav-text">队列TTL</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码框架图"><span class="toc-nav-number">7.5.1.</span> <span class="toc-nav-text">代码框架图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#配置文件类"><span class="toc-nav-number">7.5.2.</span> <span class="toc-nav-text">配置文件类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#结果展示-1"><span class="toc-nav-number">7.5.3.</span> <span class="toc-nav-text">结果展示</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#注意问题"><span class="toc-nav-number">7.5.4.</span> <span class="toc-nav-text">注意问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">7.5.5.</span> <span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#延时队列优化"><span class="toc-nav-number">7.6.</span> <span class="toc-nav-text">延时队列优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码架构图-1"><span class="toc-nav-number">7.6.1.</span> <span class="toc-nav-text">代码架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#配置文件类代码"><span class="toc-nav-number">7.6.2.</span> <span class="toc-nav-text">配置文件类代码</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息生产者-1"><span class="toc-nav-number">7.6.3.</span> <span class="toc-nav-text">消息生产者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#程序执行"><span class="toc-nav-number">7.6.4.</span> <span class="toc-nav-text">程序执行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#结果展示-2"><span class="toc-nav-number">7.6.5.</span> <span class="toc-nav-text">结果展示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Rabbitmq-插件实现延迟队列"><span class="toc-nav-number">7.7.</span> <span class="toc-nav-text">Rabbitmq 插件实现延迟队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#安装延时队列插件"><span class="toc-nav-number">7.7.1.</span> <span class="toc-nav-text">安装延时队列插件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实现延迟原理"><span class="toc-nav-number">7.7.2.</span> <span class="toc-nav-text">实现延迟原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码架构图-2"><span class="toc-nav-number">7.7.3.</span> <span class="toc-nav-text">代码架构图</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#配置文件类-1"><span class="toc-nav-number">7.7.3.1.</span> <span class="toc-nav-text">配置文件类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#消息生产者-2"><span class="toc-nav-number">7.7.3.2.</span> <span class="toc-nav-text">消息生产者</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#消息消费者-1"><span class="toc-nav-number">7.7.3.3.</span> <span class="toc-nav-text">消息消费者</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#程序执行-1"><span class="toc-nav-number">7.7.3.4.</span> <span class="toc-nav-text">程序执行</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#结果展示-3"><span class="toc-nav-number">7.7.3.5.</span> <span class="toc-nav-text">结果展示</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#总结-1"><span class="toc-nav-number">7.8.</span> <span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#8-发布确认高级"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">8.发布确认高级</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#发布确认-springboot-版本"><span class="toc-nav-number">8.1.</span> <span class="toc-nav-text">发布确认 springboot 版本</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#确认机制方案"><span class="toc-nav-number">8.1.1.</span> <span class="toc-nav-text">确认机制方案</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码架构图-3"><span class="toc-nav-number">8.1.2.</span> <span class="toc-nav-text">代码架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#配置文件"><span class="toc-nav-number">8.1.3.</span> <span class="toc-nav-text">配置文件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#添加配置类"><span class="toc-nav-number">8.1.4.</span> <span class="toc-nav-text">添加配置类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息生产者-3"><span class="toc-nav-number">8.1.5.</span> <span class="toc-nav-text">消息生产者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#回调接口"><span class="toc-nav-number">8.1.6.</span> <span class="toc-nav-text">回调接口</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息消费者-2"><span class="toc-nav-number">8.1.7.</span> <span class="toc-nav-text">消息消费者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#程序执行-2"><span class="toc-nav-number">8.1.8.</span> <span class="toc-nav-text">程序执行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#执行结果"><span class="toc-nav-number">8.1.9.</span> <span class="toc-nav-text">执行结果</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#回退消息"><span class="toc-nav-number">8.2.</span> <span class="toc-nav-text">回退消息</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Mandatory-参数"><span class="toc-nav-number">8.2.1.</span> <span class="toc-nav-text">Mandatory 参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息生产者代码"><span class="toc-nav-number">8.2.2.</span> <span class="toc-nav-text">消息生产者代码</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#回调接口-1"><span class="toc-nav-number">8.2.3.</span> <span class="toc-nav-text">回调接口</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#程序执行-3"><span class="toc-nav-number">8.2.4.</span> <span class="toc-nav-text">程序执行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#执行结果-1"><span class="toc-nav-number">8.2.5.</span> <span class="toc-nav-text">执行结果</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#备份交换机"><span class="toc-nav-number">8.3.</span> <span class="toc-nav-text">备份交换机</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#代码架构图-4"><span class="toc-nav-number">8.3.1.</span> <span class="toc-nav-text">代码架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#修改配置类"><span class="toc-nav-number">8.3.2.</span> <span class="toc-nav-text">修改配置类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#报警消费者"><span class="toc-nav-number">8.3.3.</span> <span class="toc-nav-text">报警消费者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#普通消费者"><span class="toc-nav-number">8.3.4.</span> <span class="toc-nav-text">普通消费者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息发送者"><span class="toc-nav-number">8.3.5.</span> <span class="toc-nav-text">消息发送者</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#回调接口-2"><span class="toc-nav-number">8.3.6.</span> <span class="toc-nav-text">回调接口</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#程序执行-4"><span class="toc-nav-number">8.3.7.</span> <span class="toc-nav-text">程序执行</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#执行结果-2"><span class="toc-nav-number">8.3.8.</span> <span class="toc-nav-text">执行结果</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#9-RabbitMQ其他知识"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">9.RabbitMQ其他知识</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#幂等性"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">幂等性</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#概念-2"><span class="toc-nav-number">9.1.1.</span> <span class="toc-nav-text">概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消息重复消费"><span class="toc-nav-number">9.1.2.</span> <span class="toc-nav-text">消息重复消费</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#解决思路"><span class="toc-nav-number">9.1.3.</span> <span class="toc-nav-text">解决思路</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#消费端的幂等性保障"><span class="toc-nav-number">9.1.4.</span> <span class="toc-nav-text">消费端的幂等性保障</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#唯一-ID-指纹码机制"><span class="toc-nav-number">9.1.5.</span> <span class="toc-nav-text">唯一 ID+指纹码机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Redis-原子性"><span class="toc-nav-number">9.1.6.</span> <span class="toc-nav-text">Redis 原子性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#优先级队列"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">优先级队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用场景"><span class="toc-nav-number">9.2.1.</span> <span class="toc-nav-text">使用场景</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#添加优先级队列"><span class="toc-nav-number">9.2.2.</span> <span class="toc-nav-text">添加优先级队列</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#执行结果-3"><span class="toc-nav-number">9.2.3.</span> <span class="toc-nav-text">执行结果</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#惰性队列"><span class="toc-nav-number">9.3.</span> <span class="toc-nav-text">惰性队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用场景-1"><span class="toc-nav-number">9.3.1.</span> <span class="toc-nav-text">使用场景</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#两种模式"><span class="toc-nav-number">9.3.2.</span> <span class="toc-nav-text">两种模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#内存开销对比"><span class="toc-nav-number">9.3.3.</span> <span class="toc-nav-text">内存开销对比</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#10-RabbitMQ-集群"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">10.RabbitMQ 集群</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#clustering"><span class="toc-nav-number">10.1.</span> <span class="toc-nav-text">clustering</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用集群的原因"><span class="toc-nav-number">10.1.1.</span> <span class="toc-nav-text">使用集群的原因</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#搭建步骤"><span class="toc-nav-number">10.1.2.</span> <span class="toc-nav-text">搭建步骤</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#镜像队列"><span class="toc-nav-number">10.2.</span> <span class="toc-nav-text">镜像队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#搭建步骤-1"><span class="toc-nav-number">10.2.1.</span> <span class="toc-nav-text">搭建步骤</span></a></li></ol></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#RabbitMQ" title="RabbitMQ">RabbitMQ</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/d_Nail" target="_blank">Dusign&#39;s Blog</a></li>
                    
                        <li><a href="https://github.com/eternal0918" target="_blank">Eternal&#39;s Github</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/eternal0918">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://gitee.com/dont-leave-the-old/eternal">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-git fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/Gang Du">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/hong-yan-76-83">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Eternal 2021 
                    <br>
                    Powered by 
                    <a href="https://github.com/eternal0918/eternal0918.github.io" target="_blank" rel="noopener">
                        <i>eternal.github.io</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=eternal0918&repo=eternal0918.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://dusign.net/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
